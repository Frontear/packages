#!/bin/sh

pushd "$(dirname $0)/.." >> /dev/null

GPGKEY="BCB5CEFDE22282F5"

DBEXT=".db.tar.gz"
PKGEXT=".pkg.tar.zst"

DBDIR="$PWD/x86_64"
SRCDIR="$PWD/src"
METADIR="meta"

DBNAME="$DBDIR/frontear$DBEXT"

METADEPS="$METADIR/deps"
METAHASH="$METADIR/repohash"
METABUILD="$METADIR/build"

# TODO: replace git ls-remote with anything else, its TOO SLOW
# Resolve meta information about package (symlink dependencies, get ls-remote hashes)
while read -r PACKAGE; do
    mkdir -p "$PACKAGE/$METADIR" && mkdir -p "$PACKAGE/$METADEPS"
    source "$PACKAGE/PKGBUILD"

    # strip trailing - from sha256sum
    SHA256="$(git ls-remote --heads --tags "${source##*+}" | sha256sum | awk "{print \$1}")"
    # collect all necessary dependencies for building/executing
    DEPENDS=("${checkdepends[@]}" "${depends[@]}" "${makedepends[@]}")

    # Resolve dependencies we manage that we havent already linked
    for DEP in "${DEPENDS[@]}"; do
        [ -d "$SRCDIR/$DEP" -a ! -L "$PACKAGE/$METADEPS/$DEP" ] && ln -s "$SRCDIR/$DEP" "$PACKAGE/$METADEPS/$DEP"
    done

    # Mark for building if hashes do not match (or if hash never calculated)
    [ -f "$PACKAGE/$METAHASH" ] && [ "$(cat "$PACKAGE/$METAHASH")" = "$SHA256" ] || touch "$PACKAGE/$METABUILD"

    # Write current hash for future checks
    echo "$SHA256" > "$PACKAGE/$METAHASH"
done < <(find "$SRCDIR" -mindepth 1 -maxdepth 1 -type d)

# Recursively build package by resolving and processing dependencies,
# then attaching via -I path/to/dep/package, before building
#
# $1        Directory to package containing the PKGBUILD
build() {
    [ ! -f "$1/$METABUILD" ] && return 0 # Not marked for building
    [ -f "$1"/*$PKGEXT ] && return 0 # Already built, likely from dependency recursion

    local -a depends
    local dependency

    while read -r dependency; do
        [ -z "$dependency" ] && continue
        [ -f "$dependency"/*$PKGEXT ] || build "$dependency"
        depends+=("-I $(find "$dependency" -mindepth 1 -maxdepth 1 -type f -name "*$PKGEXT")")
    done < <(find "$1/$METADEPS" -mindepth 1 -maxdepth 1 -type l -exec readlink {} \;)

    pushd "$1" >> /dev/null
    makepkg_chroot "${depends[@]}" -- "PKGEXT=$PKGEXT"
    rm "$1/$METABUILD" # Built successfully
    popd >> /dev/null
}

while read -r PACKAGE; do
    build "$PACKAGE"
done < <(find "$SRCDIR" -mindepth 1 -maxdepth 1 -type d)

# Remove old package files and move new packages to database
mkdir -p "$DBDIR"
while read -r PKGFILE; do
    PKGNAME="$(dirname $(basename "$PKGFILE"))"

    # Remove old package + old signature, and move new file to DBDIR
    find "$DBDIR" -mindepth 1 -maxdepth 1 -type f -name "$PKGNAME*$PKGEXT" -exec rm {} {}.sig \;
    mv "$PKGFILE" "$DBDIR"
done < <(find "$SRCDIR" -mindepth 2 -maxdepth 2 -type f -name "*$PKGEXT")

# Sign each package, then all together add to repo
# This generates a .old with ALL old entries
while read -r PKGFILE; do
    [ -f "$PKGFILE.sig" ] && continue # .sig is wiped if file is new from previous loop, we skip because this has existed and remained unchanged
    gpg --detach-sign --output "$PKGFILE.sig" --sign "$PKGFILE"
done < <(find "$DBDIR" -mindepth 1 -maxdepth 1 -type f -name "*PKGEXT" -a -not -name "*.sig")
find "$DBDIR" -mindepth 1 -maxdepth 1 -type f -name "*$PKGEXT" -a -not -name "*.sig" -exec repo-add --sign --verify "$DBNAME" {} +;

# Replace symlinks with solid files for pacman later
while read -r SYMLINK; do
    cd "$DBDIR"
    cp --remove-destination "$(readlink "$SYMLINK")" "$SYMLINK"
done < <(find "$DBDIR" -mindepth 1 -maxdepth 1 -type l)

# Clean all old files EXCEPT meta and PKGBUILD
find "$SRCDIR" -mindepth 2 -maxdepth 2 -not -name "PKGBUILD" -a -not -name "$METADIR" -exec rm -rf {} \;

popd >> /dev/null
